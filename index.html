<title>729</title>

<div id="container">
<canvas id="tileCanvas"></canvas>
<canvas id="bgtileCanvas"></canvas>
<canvas id="arrowCanvas"></canvas>
</div>
<div id="title">
<h1>729</h1>
</div>
<div id ="instructions">
<p>Line up three matching numbers and swipe them together. Get a <b>729</b> tile to win.</p>
</div>
<div id ="gameOver">
    <div id ="inner1">
        <p>Game over! Your score is 0.</p>
    </div>
<button onclick="newGame()" class="button">New Game</button>
</div>

<div id ="youWin">
    <div id ="inner2">
        <p">You won! Your score is 0.</p>
    </div>
<button onclick="continueGame()" class="contButton">Continue</button>
</div>

<div id ="score">
        <p">Score: </p>
</div>

<div id ="reset">
<button onclick="newGame()" class="button2">New Game</button>
</div>

<link rel="stylesheet" href="fonts/stylesheet1.css" type="text/css" charset="utf-8" />
<link rel="stylesheet" href="fonts/kit2/stylesheet.css" type="text/css" charset="utf-8" />

<style>

* {
    box-sizing: border-box
} 

body { 


	//font-family: 'just_another_handregular';
	font-family: 'nothing_you_could_sayregular';					

    overscroll-behavior: contain;

       margin: 0; 
       padding: 0
    }
#tileCanvas { 
     position: absolute;
     left: 0;
     top: 0;
     zindez: 0;
     width: 100%; 
     height: 100%; 
     overflow: hidden
   }
#bgtileCanvas { 
     position: absolute;
     left: 0;
     top: 0;
     zindez: -1;
     width: 100%; 
     height: 100%; 
     overflow: hidden
   }
#arrowCanvas { 
     position: absolute;
     left: 0;
     top: 0;
     z-index: 0;
     width: 100%; 
     height: 100%; 
     overflow: hidden
   }
#title {
    position: absolute;
    top: 0%;
    left: 0;
    right: 0;
    margin: auto;
    font-size: 70;
    display: inline-block;
    vertical-align: middle;
    text-align: center;
}
#instructions {

    position: absolute;
    top: 79%;
    left: 0;
    right: 0;
    margin: auto;
    font-size: 4vw;
    display: inline-block;
    vertical-align: middle;
    text-align: center;
}
#gameOver {

    border-radius: 25vw;
    border: 4px solid #000000;
    padding: .20vw;
    
    display: none; 
    
    background-color:white;
    position: absolute;
    top: 40%;
    left: 0;
    right: 0;
    margin: auto;
    font-size: .40vw;
    //display: inline-block;
    vertical-align: middle;
    text-align: center;
}

#youWin {

    border-radius: .25vw;
    border: 4px solid #000000;
    padding: .20vw;
    
    display: none; 
    
    background-color:white;
    position: absolute;
    top: 40%;
    left: 0;
    right: 0;
    margin: auto;
    font-size: .40vw;
    //display: inline-block;
    vertical-align: middle;
    text-align: center;
}
.button {
    background-color: #4CAF50; /* Green */
    border: none;
    color: white;
    padding: 15vw 32vw;
    text-align: center;
    text-decoration: none;
    display: inline-block;
    font-family: 'nothing_you_could_sayregular';
    font-size: .40vw;
}
.button2 {
    background-color: #4CAF50; /* Green */
    border: none;
    color: white;
    text-align: center;
    text-decoration: none;
    display: inline-block;
    font-family: 'nothing_you_could_sayregular';
    font-size: 6vw;
    display: block;
    width: 100%;
}
.contButton {
    background-color: #4CAF50; /* Green */
    border: none;
    color: white;
    padding: .15vw .32vw;
    text-align: center;
    text-decoration: none;
    display: inline-block;
    font-family: 'nothing_you_could_sayregular';
    font-size: .40px;
}
#score {

    border-radius: 2.5vw;
    border: .5vw solid #000000;
    padding: 2vw;
    
    display: inline-block; 
    
    background-color:white;
    position: absolute;
    top: 71%;
    left: 5%;
    right: 52%;
    margin: auto;
    font-size: 6vw;
    //display: inline-block;
    vertical-align: middle;
    text-align: left;
   
}
#reset {

    border-radius: 2.5vw;
    border: .5vw solid #000000;
    padding: 2vw;
    
    display: inline-block; 
    
    background-color:#4CAF50; /* Green */
    position: absolute;
    top: 71%;
    left: 52%;
    right: 5%;
    margin: auto;
    font-size: 6vw;
    //display: inline-block;
    vertical-align: middle;
    text-align: left;

</style>

<script>
// https://gist.github.com/joates/6584908
function linspace(a,b,n) {
    if(typeof n === "undefined") n = Math.max(Math.round(b-a)+1,1);
    if(n<2) { return n===1?[a]:[]; }
    var i,ret = Array(n);
    n--;
    for(i=n;i>=0;i--) { ret[i] = (i*b+(n-i)*a)/n; }
    return ret;
}
var angles = linspace(0,Math.PI * 2, 7)
var slice  = Math.PI / 6
function mod(n, m) {
        return ((n % m) + m) % m;
}


var count = 0 

var colR1  = [12,13,14]
var colR2  = [11,3,4,15]
var colR3 = [10,2,0,5,16]
var colR4  = [9,1,6,17]
var colR5  = [8,7,18]

var colG1  = [10,11,12]
var colG2  = [9,2,3,13]
var colG3 = [8,1,0,4,14]
var colG4  = [7,6,5,15]
var colG5  = [18,17,16]

var colB1  = [8,9,10]
var colB2  = [7,1,2,11]
var colB3 = [18,6,0,3,12]
var colB4  = [17,5,4,13]
var colB5  = [16,15,14]

var colList = []  // ugh i don't want all all that to a list manually

var values     = new Array(19).fill(0)
var nextValues = new Array(19).fill(0)
var slides     = new Array(19).fill(0)

var prompt = false
var won    = false

var slideValue  = []
var slide       = false
var update      = true
var first       = true  // keep animating before the first move to load the font
    
var actionQueue = []
    
var slideStartX = []
var slideStartY = []
    
var deltaX = []
var deltaY = []
    
var steps = 30
var step  = 0

// ctx is the context to add the path to
// points is a array of points [{x :?, y: ?},...
// radius is the max rounding radius 
// this creates a closed polygon.
// To draw you must call between 
//    ctx.beginPath();
//    roundedPoly(ctx, points, radius);
//    ctx.stroke();
//    ctx.fill();
// as it only adds a path and does not render. 
function roundedPoly(ctx, points, radiusAll) {
  var i, x, y, len, p1, p2, p3, v1, v2, sinA, sinA90, radDirection, drawDirection, angle, halfAngle, cRadius, lenOut,radius;
  // convert 2 points into vector form, polar form, and normalised 
  var asVec = function(p, pp, v) {
    v.x = pp.x - p.x;
    v.y = pp.y - p.y;
    v.len = Math.sqrt(v.x * v.x + v.y * v.y);
    v.nx = v.x / v.len;
    v.ny = v.y / v.len;
    v.ang = Math.atan2(v.ny, v.nx);
  }
  radius = radiusAll;
  v1 = {};
  v2 = {};
  len = points.length;
  p1 = points[len - 1];
  // for each point
  for (i = 0; i < len; i++) {
    p2 = points[(i) % len];
    p3 = points[(i + 1) % len];
    //-----------------------------------------
    // Part 1
    asVec(p2, p1, v1);
    asVec(p2, p3, v2);
    sinA = v1.nx * v2.ny - v1.ny * v2.nx;
    sinA90 = v1.nx * v2.nx - v1.ny * -v2.ny;
    angle = Math.asin(sinA);
    //-----------------------------------------
    radDirection = 1;
    drawDirection = false;
    if (sinA90 < 0) {
      if (angle < 0) {
        angle = Math.PI + angle;
      } else {
        angle = Math.PI - angle;
        radDirection = -1;
        drawDirection = true;
      }
    } else {
      if (angle > 0) {
        radDirection = -1;
        drawDirection = true;
      }
    }
    if(p2.radius !== undefined){
        radius = p2.radius;
    }else{
        radius = radiusAll;
    }
    //-----------------------------------------
    // Part 2
    halfAngle = angle / 2;
    //-----------------------------------------

    //-----------------------------------------
    // Part 3
    lenOut = Math.abs(Math.cos(halfAngle) * radius / Math.sin(halfAngle));
    //-----------------------------------------

    //-----------------------------------------
    // Special part A
    if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {
      lenOut = Math.min(v1.len / 2, v2.len / 2);
      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));
    } else {
      cRadius = radius;
    }
    //-----------------------------------------
    // Part 4
    x = p2.x + v2.nx * lenOut;
    y = p2.y + v2.ny * lenOut;
    //-----------------------------------------
    // Part 5
    x += -v2.ny * cRadius * radDirection;
    y += v2.nx * cRadius * radDirection;
    //-----------------------------------------
    // Part 6
    ctx.arc(x, y, cRadius, v1.ang + Math.PI / 2 * radDirection, v2.ang - Math.PI / 2 * radDirection, drawDirection);
    //-----------------------------------------
    p1 = p2;
    p2 = p3;
  }
  ctx.closePath();
}

function hexagon(x, y, ctx, value){
   
    var fill = false
    var fillG = 0
    var fillR = 0
    if(value % 6 == 0){
        fillR = mod(value * 50,255)
    } else {
    
        fillG = mod(value * 51,255)
    }

    var fillB = mod(value * 61,255)//Math.floor(mod((value / 81) * 255,255))
   
    if(value != 0){
        fill = true
        ctx.fillStyle = "rgba(" +fillR + "," +fillG + "," +fillB + ", 1)"; 
    }else {
        ctx.fillStyle = "rgba(245,245,220, 1)";
    }
   
    ret = offset2(x, y, 0 , circleSize/2)  // starting from angle 4 makes the hexagon in the proper place (I think)
    var cornerX = ret[0]
    var cornerY = ret[1]

    var points = []
    
    //points.push({x: ret[0],y: ret[1]})
    
    //points.push
 
    for(var h = 0; h < 6; h++){
        
        ret = offset2(cornerX, cornerY, directions[h] , circleSize/2)
        cornerX = ret[0]
        cornerY = ret[1]
        
        points.push({x: ret[0],y: ret[1]})
        //ctx.fillText("cu"+h,curveX1 , curveY1)
        //ctx.fillText("co"+h,cornerX , cornerY)
    }
    
    //ctx.fillStyle = 'black'
    
    //console.log(points)
    
    ctx.strokeStyle = 'black'
    
    ctx.lineWidth = 3
    
    if(value != 0){
        ctx.lineWidth += 4
    }
    
    ctx.beginPath()
    
    
    
    roundedPoly(ctx, points, circleSize/8)

    ctx.fill()
    
    //if(value != 0){
    ctx.stroke()
    //}

    
    if(mod(value,2) == 0 && value != 0){
        ctx.fillStyle = "#000000"
    }
    
    if(fill){
        var digits = value.toString().length
    
        ctx.fillStyle = "rgba(" + (255-fillR) + "," +(255-fillG) + "," +(255-fillB) + ", 1)"; 
        
        //https://stackoverflow.com/questions/13771310/center-proportional-font-text-in-an-html5-canvas
        ctx.textBaseline = 'middle';
        ctx.textAlign = "center";
        ctx.fillText(value.toString(), x , y )
    }
   //ctx.stroke()
}

function hexagonOld(x, y, ctx, value){
   
    var fill = false
    
    //console.log(fill)
    //console.log(x)
    //console.log(y)

    var fillG = 0
    var fillR = 0
    if(value % 6 == 0){
        fillR = mod(value * 50,255)
    } else {
    
        fillG = mod(value * 51,255)
    }

    var fillB = mod(value * 61,255)//Math.floor(mod((value / 81) * 255,255))
   
    if(value != 0){
    
        fill = true
        ctx.fillStyle = "rgba(" +fillR + "," +fillG + "," +fillB + ", 1)"; 
    }else {
    
        ctx.fillStyle = "rgba(245,245,220, 1)";
    
    }
   
    //console.log(fillB)
   
    // this is more complicated now because of curved corners
    // if you want to see how the basic version works look at the old function
   
    var radius = circleSize /10
   
    ctx.beginPath()
    ret = offset2(x, y, 0 , circleSize/2)  // starting from angle 4 makes the hexagon in the proper place (I think)
    var cornerX = ret[0]
    var cornerY = ret[1]
    ret = offset2(cornerX, cornerY, 4 , circleSize/10)
    var curveX1 = ret[0]
    var curveY1 = ret[1]
    //ctx.fillText("cu1",curveX1 , curveY1)
    //ctx.fillText("co1",cornerX , cornerY)
    
    var arcRets = []
    
    ctx.moveTo(curveX1, curveY1)
    for(var h = 0; h < 6; h++){
        
        ret = offset2(cornerX, cornerY, directions[h] , circleSize/10)
        curveX2 = ret[0]
        curveY2 = ret[1]
        //ctx.fillText("cu"+h,curveX2 , curveY2)
        //ctx.quadraticCurveTo(cornerX,cornerY, curveX2,curveY2)
        ctx.lineTo(curveX2,curveY2)
        
        arcRets.push(towards(cornerX,cornerY,x,y,radius+2))
       
        ret = offset2(cornerX, cornerY, directions[h] , circleSize*4/10)
        curveX1 = ret[0]
        curveY1 = ret[1]
        ctx.lineTo(curveX1,curveY1)
        ret = offset2(cornerX, cornerY, directions[h] , circleSize/2)
        cornerX = ret[0]
        cornerY = ret[1]
        //ctx.fillText("cu"+h,curveX1 , curveY1)
        //ctx.fillText("co"+h,cornerX , cornerY)
    }
    
    var colorString = "rgb("+fillR+ "," + fillG + "," + fillB +")"
    
    ret = offset2(cornerX, cornerY, directions[h] , circleSize/20)
    curveX2 = ret[0]
    curveY2 = ret[1]
    
    //ctx.quadraticCurveTo(cornerX,cornerY, curveX2,curveY2)
    ctx.closePath()
    

    //console.log(ctx.fillStyle)
    ctx.fill()
    
    if(mod(value,2) == 0 && value != 0){
        ctx.fillStyle = "#000000"
    }
    
    for(var h = 0; h < 6; h++){
        ctx.beginPath()
        ctx.arc(arcRets[h][0], arcRets[h][1], radius, 0,6.3)
        ctx.closePath()
        ctx.fill()
        //ctx.stroke()
    }
    
    
    if(fill){
        var digits = value.toString().length
    
        ctx.fillStyle = "rgba(" + (255-fillR) + "," +(255-fillG) + "," +(255-fillB) + ", 1)"; 
        
        //https://stackoverflow.com/questions/13771310/center-proportional-font-text-in-an-html5-canvas
        ctx.textBaseline = 'middle';
        ctx.textAlign = "center";
        ctx.fillText(value.toString(), x , y )
    }
   //ctx.stroke()
}

function towards(x1,y1,x2,y2,distance){

    var diffX = x2 - x1
    var diffY = y2 - y1

    var mag = Math.sqrt(diffX*diffX + diffY*diffY)
    var outX = x1 + diffX * distance / mag
    var outY = y1 + diffY * distance / mag
    
    return [outX,outY]
}

// these two use the angle number to look up the exact angle from the angles list
function offset(x, y, angle, factor){
    retX = x + (Math.sin(angles[angle] + slice)) * factor
    retY = y + (Math.cos(angles[angle] + slice)) * factor
    
    return [retX,retY]
}
function offset2(x, y, angle, factor){
    retX = x + (Math.sin(angles[angle])) * factor
    retY = y + (Math.cos(angles[angle])) * factor
    
    return [retX,retY]
}
// this one uses the angle in radians instead of a lookup index
function offsetExact(x, y, angle, factor){
    retX = x + (Math.sin(angle + slice)) * factor
    retY = y + (Math.cos(angle + slice)) * factor
    
    return [retX,retY]
}

var score = 0

var canvas1 = document.getElementById("tileCanvas");
var ctx1    = canvas1.getContext("2d");
var canvas2 = document.getElementById("bgtileCanvas");
var ctx2    = canvas2.getContext("2d");
var canvas3 = document.getElementById("arrowCanvas");
var ctx3    = canvas3.getContext("2d");


var height = null
var width  = null

/*
if( window.innerHeight < screen.height){
    height = window.innerHeight
} else {
    height = screen.height
}
if( window.innerWidth < screen.width){
    width = window.innerWidth
} else {
    width = screen.width
}*/

var min = width

var circleSize = width / 5
var directions = [2,3,4,5,0,1]
var posX = []
var posY = []

var fontSize = circleSize/2.5

ctx1.font= fontSize.toString() + 'px nothing_you_could_sayregular';
ctx2.font= fontSize.toString() + 'px nothing_you_could_sayregular';
ctx3.font= fontSize.toString() + 'px nothing_you_could_sayregular';

var scoreDiv = document.getElementById("score");
scoreDiv.innerText ="Score: " + score.toString()

function initCanvas(){

    canvas1 = document.getElementById("tileCanvas");
    ctx1    = canvas1.getContext("2d");
    canvas2 = document.getElementById("bgtileCanvas");
    ctx2    = canvas2.getContext("2d");
    canvas3 = document.getElementById("arrowCanvas");
    ctx3    = canvas3.getContext("2d");

    //if( window.innerHeight < screen.height){
    height = window.innerHeight
    //} else {
    //    height = screen.height
    //}
    //if( window.innerWidth < screen.width){
    width = window.innerWidth
    //} else {
    //    width = screen.width
    //}
    

    ctx1.canvas.width  = window.innerWidth; //width//
    ctx1.canvas.height = window.innerHeight; //height//
    ctx2.canvas.width  = window.innerWidth; // width//
    ctx2.canvas.height = window.innerHeight; // height//
    ctx3.canvas.width  = window.innerWidth;  // width//
    ctx3.canvas.height = window.innerHeight; // height//

    canvas1.style.zIndex = 0    // wooooow fuck that everything online had a dash in z-index for the css but it didn't actually have a dash
    canvas2.style.zIndex = -1

    //https://www.quirksmode.org/dom/w3c_cssom.html 
    //console.log(angles)
    //console.log(slice)

    var canvasLeft = canvas1.offsetLeft;
    var canvasTop  = canvas1.offsetTop;
    var count = 0
    var drawX = width/2//520
    var drawY = height*3/7  //520
    
    min = width
    if(width > height){
        //drawY = height/2
        min = height
    }
    
    
    circleSize = Math.floor(min / 5)
    directions = [2,3,4,5,0,1]
    
    fontSize = circleSize/2.5

    ctx1.font= fontSize.toString() + 'px nothing_you_could_sayregular';
    ctx2.font= fontSize.toString() + 'px nothing_you_could_sayregular';
    ctx3.font= fontSize.toString() + 'px nothing_you_could_sayregular';
    
    //ctx1.fillStyle = 'black'
    //ctx1.fillRect(drawX,drawY,100,100)
    
    posX = []
    posY = []
    posX.push(drawX)
    posY.push(drawY)
    for(var i = 0; i < 12; i++){
            
        for(var j = 0; j < i*6; j++){
        
        
            ret = offset(drawX, drawY, directions[Math.floor(j / i)], circleSize)
            drawX = ret[0]
            drawY = ret[1]
            posX.push(drawX)
            posY.push(drawY)
           
        }
        
        ret = offset(drawX, drawY, 6, circleSize)
        drawX = ret[0]
        drawY = ret[1]
    }
    
    //console.log(posX)
    //console.log(posY)

}
var shift = 0
var shift2 = 0
function drawLoop(){

    //console.log("drawstuff")

    if(update || first){
    
        ctx1.clearRect(0,0,canvas1.width,canvas1.height)
        ctx1.fillStyle='black'
        ctx1.lineStyle='black'

        count = 0
        drawX = 0
        drawY = 0
        
        var updateScore = false
        
        
        if(step >= steps){
            slide = false
            update = false      // after this we don't need to continue redrawing until we get another input
            updateScore = true  // but we do need to display the new score after we sum it below
            step  = 0
            values = nextValues.slice()

            next = actionQueue.shift()
            
            if(next){
                actionByKeyCode(next)
            }
            
            actionQueue = [] // maybe just queueing 1 is better
            
        }
        
        var winBool = false
        
        score = 0
        
        var zeros = 0
        for(var i = 0; i<values.length;i++){
        
            var value = values[i]
            score += value
            if(value == 0){
                zeros += 1 // zeros++ doesn't seem right with no semicolon
            }
            if(value == 729 && won == false){
                winBool = true
            }
        }
        
        if(updateScore){

            var scoreDiv = document.getElementById("score");
            scoreDiv.innerText ="Score: " + score.toString()
           
        }
        
        if(winBool){
            first  = false   // this won't ever matter in practice but helps development
            prompt = true
            update = false
            youWin()
        }
        
        var gameOverBool = false
        
        if(zeros == 0){
        
            if(checkGameOver()){
            
                first  = false   // this won't ever matter in practice but helps development
                prompt = true
                update = false
                gameOver()
            }
        }
        
        if(slide){
                //for(var i = 1; i < 19; i++){  //posX.length
                //    hexagon(posX[i], posY[i], ctx1, 0)// + "|" + i.toString()) //values[i])
                //}
                
                // var slideValue  = [] 
                // var slideStartX = []
                // var slideStartY = []
                // var deltaX = []
                // var deltaY = []
                //var steps = 200
                //var step  = 0
                
                for(var i = 0; i < slideValue.length; i++){
                
                    if(slideValue[i] != -1){
                
                        hexagon(slideStartX[i] + deltaX[i] * step,
                                slideStartY[i] + deltaY[i] * step,
                                ctx1,
                                slideValue[i])
                            
                    }
                }
                
                step = step + 1 // I like this better than ++ now idk why. Like you can tell at a glance it's doing assignment
        } else {
            update = false
            for(var i = 0; i < 19; i++){  //posX.length
                if(values[i] != 0){
                    hexagon(posX[i], posY[i], ctx1, values[i])// + "|" + i.toString()) //values[i])
                }
            }
       
        }
    
    }

    window.requestAnimationFrame(drawLoop)
    
}


function checkGameOver(){
    
    var slide = 0
  
    slide += checkCol(colR1)
    slide += checkCol(colR2)
    slide += checkCol(colR3)
    slide += checkCol(colR4)
    slide += checkCol(colR5)
    slide += checkCol(colG1)
    slide += checkCol(colG2)
    slide += checkCol(colG3)
    slide += checkCol(colG4)
    slide += checkCol(colG5)
    slide += checkCol(colB1)
    slide += checkCol(colB2)
    slide += checkCol(colB3)
    slide += checkCol(colB4)
    slide += checkCol(colB5)
    
    //console.log("slide from checklose:" + slide.toString())
    
    if(slide){
        return false
    } else {
        return true
    }
}

function youWin(){

    won = true
    var winDiv = document.getElementById("youWin");
    var innerDiv = document.getElementById("inner1");
    inner1.innerText =" You Won! Your score is "+ score.toString() + "."
    winDiv.style.display = 'inline-block'
    
}

function continueGame(){

    var winDiv = document.getElementById("youWin");
    winDiv.style.display = 'none'
    prompt = false

}

function gameOver(){

    var overDiv = document.getElementById("gameOver");
    var innerDiv = document.getElementById("inner1");
    innerDiv.innerText ="Game over! Your score is "+ score.toString() + "."
    overDiv.style.display = 'inline-block'

}

function newGame(){

    nextValues.fill(0)
    
    score = 0
    
    addRandom()
    addRandom()
    
    values = nextValues.slice()
    
    prompt = false
    update = true
    
    var overDiv = document.getElementById("gameOver");
    overDiv.style.display = 'none'

}

// jsperf.com javascript performance website

function checkCol(col){

    var check = 0
    var count = 0
    
    var maxCount = 0
    
    for(var i = 0; i < col.length; i++){
        var val = values[col[i]]
        
        if(val == check){
            count += 1
        } else {
            count = 1
            check = val
        }
        
        if(count > maxCount){
        
            maxCount = count
        
        }
        
        if(count == 3){
            return true
        }
    }
    return false
}

function slideCol(col, up){

    //console.log('slide col')

    var slide = false   // this one we return an allows us to keep track if anything slid at all

    var runValue = 0
    var run      = 0
    
    if(! up){
        col = col.slice().reverse()  // don't want to reverse original list
    }
    
    var outCol        = []
    var slideStarts   = []
    var targetMarker  = 0   // index of where slides target
   
    //console.log("col")
    //console.log(col)
    
    var zeroGap = false
    
    for(var i = 0; i < col.length; i++){
    
        //console.log(outCol)
    
        var value = values[col[i]]
        
        //console.log("value:    " + value.toString())
        //console.log("runValue: " + runValue.toString())
        //console.log("run:      " + run.toString())
        
        if(value == 0){
            zeroGap = true
        } else {
        
            if(zeroGap){
                slide = true
            }
        
            if(value == runValue){
                run = run + 1
                if(run == 2){
                    slides[col[i]] = col[targetMarker]
                    slideStarts.push(col[i])
                    targetMarker = targetMarker + 1
                    outCol.push(value)
                }
                
                else if(run == 3){
                    slide = true
                
                    runValue = 0
                    run      = 0
                    outCol.pop(value)
                    outCol.pop(value)
                    outCol.push(value * 3)
                    targetMarker = targetMarker - 2
                  
                    slides[col[i]]    = col[targetMarker]
                    slides[slideStarts[0]] = col[targetMarker]
                    //slides[slideStarts[1]] = col[targetMarker]
                    
                    targetMarker = targetMarker + 1
                    slideStarts = []                  
                }
            }
            
            else{
            
                slideStarts = []
                slides[col[i]] = col[targetMarker]
                targetMarker = targetMarker + 1
                outCol.push(value)
                
                runValue   = value
                run        = 1

            }
        }
    }
    
    for(var i = 0; i < col.length; i++){
    
        if(i < outCol.length){
            nextValues[col[i]] = outCol[i]
        }   else {
            nextValues[col[i]] = 0
        }
        
    }
    
    if(slide){
        return 1
    }
    else {
        return 0
    }
}

function addRandom(){

    //console.log('adding random')
    var pickList = []

    for(var i = 0; i < values.length; i++){
        if(nextValues[i] == 0){
            pickList.push(i)
        }
    }

    var pick = pickList[Math.floor(Math.random()*pickList.length)];
    
    if(Math.random() > 5/9){
        nextValues[pick] = 3
    } else {
        nextValues[pick] = 1
    }
    //nextValues[0] = 3
  
}

function slideR(up){
    if(!prompt){
        nextValues = values.slice()
        slides = new Array(19).fill(-1)  // slides go from current position index (old values) to target position index
        
        var a  = slideCol(colR1,up)
        var b  = slideCol(colR2,up)
        var c  = slideCol(colR3,up)
        var d  = slideCol(colR4,up)
        var e  = slideCol(colR5,up)
        
        if(a+b+c+d+e > 0){
            addRandom()
        }
        update = true
        first = false  
        animate()
    }
}
function slideG(up){
    if(!prompt){
        nextValues = values.slice()
        slides = new Array(19).fill(-1)  // slides go from current position index(old values) to target position index
        
        var a  = slideCol(colG1,up)
        var b  = slideCol(colG2,up)
        var c  = slideCol(colG3,up)
        var d  = slideCol(colG4,up)
        var e  = slideCol(colG5,up)
        
        var sum = a+b+c+d+e
        if(sum > 0){
            addRandom()
        }
        update = true
        first = false
        animate()
    }
}
function slideB(up){
    if(!prompt){
        nextValues = values.slice()
        slides = new Array(19).fill(-1)  // slides go from current position index (old values) to target position index
        
        var a  = slideCol(colB1,up)
        var b  = slideCol(colB2,up)
        var c  = slideCol(colB3,up)
        var d  = slideCol(colB4,up)
        var e  = slideCol(colB5,up)
        if(a+b+c+d+e > 0){
            addRandom()
        }
        update = true
        first = false
        animate()
    }
}

function drawUI(valid){

    var UImidX = canvas2.width - 200
    var UImidY =  200
    
    if(valid){
    
        var X1 = UImidX - 15
        var Y1 = UImidY
        var X2 = UImidX
        var Y2 = UImidY + 15
        var X3 = UImidX + 30
        var Y3 = UImidY - 30
        
        ctx2.moveTo(X1,Y1)
        ctx2.lineTo(X2,Y2)
        ctx2.lineTo(X3,Y3)
        ctx2.lineStyle = 'green'
        ctx2.stroke()
 
    } else {
    
        ctx2.clearRect(0,0,canvas2.width,canvas2.height);
    
        var X1 = UImidX - 30
        var Y1 = UImidX + 30
        var X2 = UImidX + 30
        var Y2 = UImidX - 30    
        var X3 = UImidX - 30
        var Y3 = UImidX - 30
        var X4 = UImidX + 30
        var Y4 = UImidX + 30
        ctx2.moveTo(X1,Y1)
        ctx2.lineTo(X2,Y2)
        ctx2.moveTo(X3,Y3)
        ctx2.lineTo(X4,Y4)
        ctx2.lineStyle = 'black'
        ctx2.stroke()
    }
    
    drawStuff()
    
}


// direction codes :
// up right   = 0   
// up left    = 1
// left       = 2
// down left  = 3
// down right = 4
// right      = 5


function animate(){

    slideValue  = []
    slide       = false
    
    slideStartX = []
    slideStartY = []
    
    deltaX = []
    deltaY = []

    for (var i = 0; i < slides.length; i++){
        if(slides[i] != -1){
              
            slideStartX.push(posX[i])
            slideStartY.push(posY[i])
            
            diffX = (posX[slides[i]] - posX[i]) / steps   // subtract original location from target
            diffY = (posY[slides[i]] - posY[i]) / steps   // because we want to end up at target by adding it back 
            
            deltaX.push(diffX)
            deltaY.push(diffY)
            
            slideValue.push(values[i])
            
        }
    }
    
    slide = true

}


// w = 87
// e = 69
// d = 68
// x = 88
// z = 90
// a = 65

document.onkeydown = function(e) {
    if(! update){
        actionByKeyCode(e.keyCode)
    }
    else{
        actionQueue.push(e.keyCode)
    }
}

function actionByKeyCode(code){
    switch (code) {
        case 87: // w
            slideB(false)
            break
        case 69: // e
            slideR(true)
            break    
        case 68: // d
            slideG(true)
            break
        case 88: // x
            slideB(true)
            break
        case 90: // z
            slideR(false)
            break
        case 65: // a
            slideG(false)
            break
    }
}


document.addEventListener('touchstart', handleTouchStart, false);        
document.addEventListener('touchmove', handleTouchMove, false);

var xDown = null;                                                        
var yDown = null;

function getTouches(evt) {
  return evt.touches ||             // browser API
         evt.originalEvent.touches; // jQuery
}                                                     

function handleTouchStart(evt) {                                         
    xDown = getTouches(evt)[0].clientX;                                      
    yDown = getTouches(evt)[0].clientY;                                      
};                                                

function handleTouchMove(evt) {
    if ( ! xDown || ! yDown ) {
        return;
    }

    var xUp = evt.touches[0].clientX;                                    
    var yUp = evt.touches[0].clientY;

    var xDiff = xDown - xUp;
    var yDiff = yDown - yUp;    
    
    var rad = (Math.atan2(yDiff, xDiff) / Math.PI) + 1;
    
    //ctx1.fillText(rad, 500,500)
    
    //console.log(rad)
    
    if(rad > (1/6) && rad <= (3/6)){
    //console.log('e , rad > 1/6 && rad <= 3/6, rad: ' + rad.toString())
    // e
    slideB(true)
    }
    else if(rad > (1/2) && rad <= (5/6)){
    //console.log('w , rad > 1/2 && rad <= 5/6, rad: ' + rad.toString())
    // w
    slideR(false)
    }
    else if(rad > (5/6) && rad <= (7/6)){
    //console.log('a , rad > 5/6 && rad <= 7/6, rad: ' + rad.toString())
    // a
     slideG(false)
    }
    else if(rad > (7/6) && rad <= (9/6)){
    //console.log('z , rad > 7/6 && rad <= 9/6, rad: ' + rad.toString())
    // z
    slideB(false)
    }
    else if(rad > (9/6) && rad <= (11/6)){
    //console.log('x , rad > 9/6 && rad <= 11/6, rad: ' + rad.toString())
    //  x
    slideR(true)
    }else{
    //console.log('d , other rad,                rad: ' + rad.toString())
    // d
    slideG(true)
    }
    /* reset values */
    xDown = null;
    yDown = null;                                             
};

//console.log(canvas1)

initCanvas()

for(var i = 0; i < 19; i++){  //posX.length
   
    hexagon(posX[i], posY[i], ctx2, values[i])// + "|" + i.toString()) //values[i])
   
}

addRandom()
addRandom()

//nextValues[0] = 1
//nextValues[1] = 2
//nextValues[4] = 3
//nextValues[8] = 4

values = nextValues.slice()
update = true
drawLoop()
//console.log(values)


</script>