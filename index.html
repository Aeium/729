<title>729</title>

<div id="container">
<canvas id="tileCanvas"></canvas>
<canvas id="bgtileCanvas"></canvas>
<canvas id="arrowCanvas"></canvas>
</div>
<div id="title">
<h1>729</h1>
</div>
<div id ="instructions">
<p>Line up three matching numbers and swipe them together. Get a 729 tile to win.</p>
</div>

<link rel="stylesheet" href="fonts/stylesheet1.css" type="text/css" charset="utf-8" />
<link rel="stylesheet" href="fonts/kit2/stylesheet.css" type="text/css" charset="utf-8" />


<style>

body { 


	//font-family: 'just_another_handregular';
	font-family: 'nothing_you_could_sayregular';					

    overscroll-behavior: contain;

       margin: 0; 
       padding: 0
    }
#tileCanvas { 
     position: absolute;
     left: 0;
     top: 0;
     zindez: 0;
     width: 100%; 
     height: 100%; 
     overflow: hidden
   }
#bgtileCanvas { 
     position: absolute;
     left: 0;
     top: 0;
     zindez: -1;
     width: 100%; 
     height: 100%; 
     overflow: hidden
   }
#arrowCanvas { 
     position: absolute;
     left: 0;
     top: 0;
     z-index: 0;
     width: 100%; 
     height: 100%; 
     overflow: hidden
   }
#title {
    position: absolute;
    top: 0%;
    left: 0;
    right: 0;
    margin: auto;
    font-size: 70;
    display: inline-block;
    vertical-align: middle;
    text-align: center;
}
#instructions {
    position: absolute;
    top: 70%;
    left: 0;
    right: 0;
    margin: auto;
    font-size: 40;
    display: inline-block;
    vertical-align: middle;
    text-align: center;
}
</style>

<script>
// https://gist.github.com/joates/6584908
function linspace(a,b,n) {
    if(typeof n === "undefined") n = Math.max(Math.round(b-a)+1,1);
    if(n<2) { return n===1?[a]:[]; }
    var i,ret = Array(n);
    n--;
    for(i=n;i>=0;i--) { ret[i] = (i*b+(n-i)*a)/n; }
    return ret;
}
var angles = linspace(0,Math.PI * 2, 7)
var slice  = Math.PI / 6
function mod(n, m) {
        return ((n % m) + m) % m;
}


var count = 0 

var colR1  = [12,13,14]
var colR2  = [11,3,4,15]
var colR3 = [10,2,0,5,16]
var colR4  = [9,1,6,17]
var colR5  = [8,7,18]

var colG1  = [10,11,12]
var colG2  = [9,2,3,13]
var colG3 = [8,1,0,4,14]
var colG4  = [7,6,5,15]
var colG5  = [18,17,16]

var colB1  = [8,9,10]
var colB2  = [7,1,2,11]
var colB3 = [18,6,0,3,12]
var colB4  = [17,5,4,13]
var colB5  = [16,15,14]

var colList = []  // ugh i don't want all all that to a list manually

var values     = new Array(19).fill(0)
var nextValues = new Array(19).fill(0)
var slides     = new Array(19).fill(0)

var leftArrow  = false
var upArrow    = false
var rightArrow = false
var downArrow  = false

var enterKey   = false

var slideValue  = []
var slide       = false
var update      = true
var first       = true  // keep animating before the first move to load the font
    
var actionQueue = []
    
var slideStartX = []
var slideStartY = []
    
var deltaX = []
var deltaY = []
    
var steps = 30
var step  = 0

function hexagon(x, y, ctx, value){
   
    var fill = false
    
    //console.log(fill)
    //console.log(x)
    //console.log(y)

    var fillG = 0
    var fillR = 0
    if(value % 6 == 0){
        fillR = mod(value * 50,255)
    } else {
    
        fillG = mod(value * 51,255)
    }

    var fillB = mod(value * 61,255)//Math.floor(mod((value / 81) * 255,255))
   
    if(value != 0){
    
        fill = true
        ctx.fillStyle = "rgba(" +fillR + "," +fillG + "," +fillB + ", 1)"; 
    }else {
    
        ctx.fillStyle = "rgba(245,245,220, 1)";
    
    }
   
    //console.log(fillB)
   
    // this is more complicated now because of curved corners
    // if you want to see how the basic version works look at the old function
   
    var radius = cicleSize/20 
   
    ctx.beginPath()
    ret = offset2(x, y, 0 , cicleSize/2)  // starting from angle 4 makes the hexagon in the proper place (I think)
    var cornerX = ret[0]
    var cornerY = ret[1]
    ret = offset2(cornerX, cornerY, 4 , cicleSize/20)
    var curveX1 = ret[0]
    var curveY1 = ret[1]
    //ctx.fillText("cu1",curveX1 , curveY1)
    //ctx.fillText("co1",cornerX , cornerY)
    
    var arcRets = []
    
    ctx.moveTo(curveX1, curveY1)
    for(var h = 0; h < 6; h++){
        
        ret = offset2(cornerX, cornerY, directions[h] , cicleSize/20)
        curveX2 = ret[0]
        curveY2 = ret[1]
        //ctx.fillText("cu"+h,curveX2 , curveY2)
        //ctx.quadraticCurveTo(cornerX,cornerY, curveX2,curveY2)
        ctx.lineTo(curveX2,curveY2)
        
        arcRets.push(towards(cornerX,cornerY,x,y,radius+2))
       
        ret = offset2(cornerX, cornerY, directions[h] , cicleSize*9/20)
        curveX1 = ret[0]
        curveY1 = ret[1]
        ctx.lineTo(curveX1,curveY1)
        ret = offset2(cornerX, cornerY, directions[h] , cicleSize/2)
        cornerX = ret[0]
        cornerY = ret[1]
        //ctx.fillText("cu"+h,curveX1 , curveY1)
        //ctx.fillText("co"+h,cornerX , cornerY)
    }
    
    var colorString = "rgb("+fillR+ "," + fillG + "," + fillB +")"
    
    ret = offset2(cornerX, cornerY, directions[h] , cicleSize/20)
    curveX2 = ret[0]
    curveY2 = ret[1]
    
    //ctx.quadraticCurveTo(cornerX,cornerY, curveX2,curveY2)
    ctx.closePath()
    
    
    //console.log(ctx.fillStyle)
    ctx.fill()
    
    if(mod(value,2) == 0 && value != 0){
        ctx.fillStyle = "#000000"
    }
    
    for(var h = 0; h < 6; h++){
        ctx.beginPath()
        ctx.arc(arcRets[h][0], arcRets[h][1], radius, 0,6.3)
        ctx.closePath()
        ctx.fill()
        //ctx.stroke()
    }
    
    
    if(fill){
        var digits = value.toString().length
    
        ctx.fillStyle = "rgba(" + (255-fillR) + "," +(255-fillG) + "," +(255-fillB) + ", 1)"; 
        
        //https://stackoverflow.com/questions/13771310/center-proportional-font-text-in-an-html5-canvas
        ctx.textBaseline = 'middle';
        ctx.textAlign = "center";
        ctx.fillText(value.toString(), x , y )
    }
   //ctx.stroke()
   

}

function towards(x1,y1,x2,y2,distance){

    var diffX = x2 - x1
    var diffY = y2 - y1

    var mag = Math.sqrt(diffX*diffX + diffY*diffY)
    var outX = x1 + diffX * distance / mag
    var outY = y1 + diffY * distance / mag
    
    return [outX,outY]
}

// these two use the angle number to look up the exact angle from the angles list
function offset(x, y, angle, factor){
    retX = x + (Math.sin(angles[angle] + slice)) * factor
    retY = y + (Math.cos(angles[angle] + slice)) * factor
    
    return [retX,retY]
}
function offset2(x, y, angle, factor){
    retX = x + (Math.sin(angles[angle])) * factor
    retY = y + (Math.cos(angles[angle])) * factor
    
    return [retX,retY]
}
// this one uses the angle in radians instead of a lookup index
function offsetExact(x, y, angle, factor){
    retX = x + (Math.sin(angle + slice)) * factor
    retY = y + (Math.cos(angle + slice)) * factor
    
    return [retX,retY]
}

var canvas1 = document.getElementById("tileCanvas");
var ctx1    = canvas1.getContext("2d");
var canvas2 = document.getElementById("bgtileCanvas");
var ctx2    = canvas2.getContext("2d");
var canvas3 = document.getElementById("arrowCanvas");
var ctx3    = canvas3.getContext("2d");


var height = null
var width  = null

if( window.innerHeight < screen.height){
    height = window.innerHeight
} else {
    height = screen.height
}
if( window.innerWidth < screen.width){
    width = window.innerWidth
} else {
    width = screen.width
}

var min = width

var cicleSize = width / 5
var directions = [2,3,4,5,0,1]
var posX = []
var posY = []

var fontSize = cicleSize/2.5

ctx1.font= fontSize.toString() + 'px nothing_you_could_sayregular';
ctx2.font= fontSize.toString() + 'px nothing_you_could_sayregular';
ctx3.font= fontSize.toString() + 'px nothing_you_could_sayregular';

function initCanvas(){

    canvas1 = document.getElementById("tileCanvas");
    ctx1    = canvas1.getContext("2d");
    canvas2 = document.getElementById("bgtileCanvas");
    ctx2    = canvas2.getContext("2d");
    canvas3 = document.getElementById("arrowCanvas");
    ctx3    = canvas3.getContext("2d");

    if( window.innerHeight < screen.height){
        height = window.innerHeight
    } else {
        height = screen.height
    }
    if( window.innerWidth < screen.width){
        width = window.innerWidth
    } else {
        width = screen.width
    }
    

    ctx1.canvas.width  = width//window.innerWidth;
    ctx1.canvas.height = height//window.innerHeight;
    ctx2.canvas.width  = width//window.innerWidth;
    ctx2.canvas.height = height//window.innerHeight;
    ctx3.canvas.width  = width//window.innerWidth;
    ctx3.canvas.height = height//window.innerHeight;

    canvas1.style.zIndex = 0    // wooooow fuck that everything online had a dash in z-index for the css but it didn't actually have a dash
    canvas2.style.zIndex = -1

    //https://www.quirksmode.org/dom/w3c_cssom.html 
    //console.log(angles)
    //console.log(slice)

    var canvasLeft = canvas1.offsetLeft;
    var canvasTop  = canvas1.offsetTop;
    var count = 0
    var drawX = width/2//520
    var drawY = height*3/7  //520
    
    min = width
    if(width > height){
        //drawY = height/2
        min = height
    }
    
    
    cicleSize = Math.floor(min / 5)
    directions = [2,3,4,5,0,1]
    
    fontSize = cicleSize/2.5

ctx1.font= fontSize.toString() + 'px nothing_you_could_sayregular';
ctx2.font= fontSize.toString() + 'px nothing_you_could_sayregular';
ctx3.font= fontSize.toString() + 'px nothing_you_could_sayregular';
    
    //ctx1.fillStyle = 'black'
    //ctx1.fillRect(drawX,drawY,100,100)
    
    posX = []
    posY = []
    posX.push(drawX)
    posY.push(drawY)
    for(var i = 0; i < 12; i++){
            
        for(var j = 0; j < i*6; j++){
        
        
            ret = offset(drawX, drawY, directions[Math.floor(j / i)], cicleSize)
            drawX = ret[0]
            drawY = ret[1]
            posX.push(drawX)
            posY.push(drawY)
           
        }
        
        ret = offset(drawX, drawY, 6, cicleSize)
        drawX = ret[0]
        drawY = ret[1]
    }
    
    //console.log(posX)
    //console.log(posY)

}
var shift = 0
var shift2 = 0
function drawLoop(){

    //console.log("drawstuff")

    if(update || first){
    
        ctx1.clearRect(0,0,canvas1.width,canvas1.height)
        ctx1.fillStyle='black'
        ctx1.lineStyle='black'

        count = 0
        drawX = 0
        drawY = 0
        
        
        if(step >= steps){
            slide = false
            update = false
            step  = 0
            values = nextValues.slice()

            next = actionQueue.shift()
            
            if(next){
                actionByKeyCode(next)
            }
            
            actionQueue = [] // maybe just queueing 1 is better
            
        }
        
        var score = 0
        var zeros = 0
        for(var i = 0; i<values.length;i++){
        
            var value = values[i]
            score += value
            if(value == 0){
                zeros += 1 // zeros++ doesn't seem right with no semicolon
            }
        }
        
        var gameOverBool = false
        
        if(zeros == 0){
        
            if(checkGameOver()){
            
                gameOverBool = true
                gameOver()
            }
        }
        
        ctx1.fillStyle="#000000";
        ctx1.fillText("Score : "+ score.toString(), 850, 100) 
        
        if(slide){
                //for(var i = 1; i < 19; i++){  //posX.length
                //    hexagon(posX[i], posY[i], ctx1, 0)// + "|" + i.toString()) //values[i])
                //}
                
                // var slideValue  = [] 
                // var slideStartX = []
                // var slideStartY = []
                // var deltaX = []
                // var deltaY = []
                //var steps = 200
                //var step  = 0
                
                for(var i = 0; i < slideValue.length; i++){
                
                    if(slideValue[i] != -1){
                
                        hexagon(slideStartX[i] + deltaX[i] * step,
                                slideStartY[i] + deltaY[i] * step,
                                ctx1,
                                slideValue[i])
                            
                    }
                }
                
                step = step + 1 // I like this better than ++ now idk why. Like you can tell at a glance it's doing assignment
        } else {
            update = false
            for(var i = 0; i < 19; i++){  //posX.length
                if(values[i] != 0){
                    hexagon(posX[i], posY[i], ctx1, values[i])// + "|" + i.toString()) //values[i])
                }
            }
       
        }
    
    }

    window.requestAnimationFrame(drawLoop)
    
}


function checkGameOver(){
    
    var slide = 0
  
    slide += checkCol(colR1)
    slide += checkCol(colR2)
    slide += checkCol(colR3)
    slide += checkCol(colR4)
    slide += checkCol(colR5)
    slide += checkCol(colG1)
    slide += checkCol(colG2)
    slide += checkCol(colG3)
    slide += checkCol(colG4)
    slide += checkCol(colG5)
    slide += checkCol(colB1)
    slide += checkCol(colB2)
    slide += checkCol(colB3)
    slide += checkCol(colB4)
    slide += checkCol(colB5)
    
    console.log("slide from checklose:" + slide.toString())
    
    if(slide){
        return false
    } else {
        return true
    }
}

// jsperf.com javascript performance website

function checkCol(col){

    var check = 0
    var count = 0
    
    var maxCount = 0
    
    for(var i = 0; i < col.length; i++){
        var val = values[col[i]]
        
        if(val == check){
            count += 1
        } else {
            count = 1
            check = val
        }
        
        if(count > maxCount){
        
            maxCount = count
        
        }
        
        if(count == 3){
            return true
        }
    }
    return false
}

function slideCol(col, up){

    //console.log('slide col')

    var slide = false   // this one we return an allows us to keep track if anything slid at all

    var runValue = 0
    var run      = 0
    
    if(! up){
        col = col.slice().reverse()  // don't want to reverse original list
    }
    
    var outCol        = []
    var slideStarts   = []
    var targetMarker  = 0   // index of where slides target
   
    //console.log("col")
    //console.log(col)
    
    var zeroGap = false
    
    for(var i = 0; i < col.length; i++){
    
        //console.log(outCol)
    
        var value = values[col[i]]
        
        //console.log("value:    " + value.toString())
        //console.log("runValue: " + runValue.toString())
        //console.log("run:      " + run.toString())
        
        if(value == 0){
        
            zeroGap = true
        
        } else {
        
            if(zeroGap){
            
                slide = true
            
            }
        
            if(value == runValue){
            
                run = run + 1
                
                if(run == 2){
                    
                    slides[col[i]] = col[targetMarker]
                    slideStarts.push(col[i])
                    targetMarker = targetMarker + 1
                    outCol.push(value)
                }
                
                else if(run == 3){
                    slide = true
                
                    //console.log("run of 3")
                    console.log(targetMarker)
                
                    runValue = 0
                    run      = 0
                    outCol.pop(value)
                    outCol.pop(value)
                    outCol.push(value * 3)
                    targetMarker = targetMarker - 2
                  
                    slides[col[i]]    = col[targetMarker]
                    slides[slideStarts[0]] = col[targetMarker]
                    //slides[slideStarts[1]] = col[targetMarker]
                    
                    targetMarker = targetMarker + 1
                    slideStarts = []                  
                }
            }
            
            else{
            
                slideStarts = []
                slides[col[i]] = col[targetMarker]
                targetMarker = targetMarker + 1
                outCol.push(value)
                
                runValue   = value
                run        = 1

            }
        }
    }
    
    for(var i = 0; i < col.length; i++){
    
        if(i < outCol.length){
            nextValues[col[i]] = outCol[i]
        }   else {
            nextValues[col[i]] = 0
        }
        
    }
    
    if(slide){
        return 1
    }
    else {
        return 0
    }
    
}

function addRandom(){

    //console.log('adding random')
    var pickList = []

    for(var i = 0; i < values.length; i++){
        if(nextValues[i] == 0){
            pickList.push(i)
        }
    }
    
    
    
    var pick = pickList[Math.floor(Math.random()*pickList.length)];
    
    if(Math.random() > 5/9){
        nextValues[pick] = 3
    } else {
        nextValues[pick] = 1
    }
    //nextValues[0] = 3
  
}

function slideR(up){

    nextValues = values.slice()
    slides = new Array(19).fill(-1)  // slides go from current position index (old values) to target position index
    
    var a  = slideCol(colR1,up)
    var b  = slideCol(colR2,up)
    var c  = slideCol(colR3,up)
    var d  = slideCol(colR4,up)
    var e  = slideCol(colR5,up)
    
    if(a+b+c+d+e > 0){
        addRandom()
    }
    update = true
    first = false  
    animate()
}
function slideG(up){

    nextValues = values.slice()
    slides = new Array(19).fill(-1)  // slides go from current position index(old values) to target position index
    
    var a  = slideCol(colG1,up)
    var b  = slideCol(colG2,up)
    var c  = slideCol(colG3,up)
    var d  = slideCol(colG4,up)
    var e  = slideCol(colG5,up)
    
    var sum = a+b+c+d+e
    if(sum > 0){
        addRandom()
    }
    update = true
    first = false
    animate()
}
function slideB(up){

    nextValues = values.slice()
    slides = new Array(19).fill(-1)  // slides go from current position index (old values) to target position index
    
    var a  = slideCol(colB1,up)
    var b  = slideCol(colB2,up)
    var c  = slideCol(colB3,up)
    var d  = slideCol(colB4,up)
    var e  = slideCol(colB5,up)
    if(a+b+c+d+e > 0){
        addRandom()
    }
    update = true
    first = false
    animate()
}

function drawUI(valid){

    var UImidX = canvas2.width - 200
    var UImidY =  200
    
    if(valid){
    
        var X1 = UImidX - 15
        var Y1 = UImidY
        var X2 = UImidX
        var Y2 = UImidY + 15
        var X3 = UImidX + 30
        var Y3 = UImidY - 30
        
        ctx2.moveTo(X1,Y1)
        ctx2.lineTo(X2,Y2)
        ctx2.lineTo(X3,Y3)
        ctx2.lineStyle = 'green'
        ctx2.stroke()
 
    } else {
    
        ctx2.clearRect(0,0,canvas2.width,canvas2.height);
    
        var X1 = UImidX - 30
        var Y1 = UImidX + 30
        var X2 = UImidX + 30
        var Y2 = UImidX - 30    
        var X3 = UImidX - 30
        var Y3 = UImidX - 30
        var X4 = UImidX + 30
        var Y4 = UImidX + 30
        ctx2.moveTo(X1,Y1)
        ctx2.lineTo(X2,Y2)
        ctx2.moveTo(X3,Y3)
        ctx2.lineTo(X4,Y4)
        ctx2.lineStyle = 'black'
        ctx2.stroke()
    }
    
    drawStuff()
    
}


// direction codes :
// up right   = 0   
// up left    = 1
// left       = 2
// down left  = 3
// down right = 4
// right      = 5


function animate(){

    slideValue  = []
    slide       = false
    
    slideStartX = []
    slideStartY = []
    
    deltaX = []
    deltaY = []

    for (var i = 0; i < slides.length; i++){
        if(slides[i] != -1){
              
            slideStartX.push(posX[i])
            slideStartY.push(posY[i])
            
            diffX = (posX[slides[i]] - posX[i]) / steps   // subtract original location from target
            diffY = (posY[slides[i]] - posY[i]) / steps   // because we want to end up at target by adding it back 
            
            deltaX.push(diffX)
            deltaY.push(diffY)
            
            slideValue.push(values[i])
            
        }
    }
    
    slide = true

}


// w = 87
// e = 69
// d = 68
// x = 88
// z = 90
// a = 65

document.onkeydown = function(e) {
    if(! update){
        actionByKeyCode(e.keyCode)
    }
    else{
        actionQueue.push(e.keyCode)
    }
}

function actionByKeyCode(code){
    switch (code) {
        case 87: // w
            slideB(false)
            break
        case 69: // e
            slideR(true)
            break    
        case 68: // d
            slideG(true)
            break
        case 88: // x
            slideB(true)
            break
        case 90: // z
            slideR(false)
            break
        case 65: // a
            slideG(false)
            break
    }
}


document.addEventListener('touchstart', handleTouchStart, false);        
document.addEventListener('touchmove', handleTouchMove, false);

var xDown = null;                                                        
var yDown = null;

function getTouches(evt) {
  return evt.touches ||             // browser API
         evt.originalEvent.touches; // jQuery
}                                                     

function handleTouchStart(evt) {                                         
    xDown = getTouches(evt)[0].clientX;                                      
    yDown = getTouches(evt)[0].clientY;                                      
};                                                

function handleTouchMove(evt) {
    if ( ! xDown || ! yDown ) {
        return;
    }

    var xUp = evt.touches[0].clientX;                                    
    var yUp = evt.touches[0].clientY;

    var xDiff = xDown - xUp;
    var yDiff = yDown - yUp;    
    
    var rad = (Math.atan2(yDiff, xDiff) / Math.PI) + 1;
    
    //ctx1.fillText(rad, 500,500)
    
    //console.log(rad)
    
    if(rad > (1/6) && rad <= (3/6)){
    //console.log('e , rad > 1/6 && rad <= 3/6, rad: ' + rad.toString())
    // e
    slideB(true)
    }
    else if(rad > (1/2) && rad <= (5/6)){
    //console.log('w , rad > 1/2 && rad <= 5/6, rad: ' + rad.toString())
    // w
    slideR(false)
    }
    else if(rad > (5/6) && rad <= (7/6)){
    //console.log('a , rad > 5/6 && rad <= 7/6, rad: ' + rad.toString())
    // a
     slideG(false)
    }
    else if(rad > (7/6) && rad <= (9/6)){
    //console.log('z , rad > 7/6 && rad <= 9/6, rad: ' + rad.toString())
    // z
    slideB(false)
    }
    else if(rad > (9/6) && rad <= (11/6)){
    //console.log('x , rad > 9/6 && rad <= 11/6, rad: ' + rad.toString())
    //  x
    slideR(true)
    }else{
    //console.log('d , other rad,                rad: ' + rad.toString())
    // d
    slideG(true)
    }
    /* reset values */
    xDown = null;
    yDown = null;                                             
};

//console.log(canvas1)

initCanvas()

for(var i = 0; i < 19; i++){  //posX.length
   
    hexagon(posX[i], posY[i], ctx2, values[i])// + "|" + i.toString()) //values[i])
   
}

addRandom()
addRandom()

//nextValues[0] = 1
//nextValues[1] = 2
//nextValues[4] = 3
//nextValues[8] = 4

values = nextValues.slice()
update = true
drawLoop()
//console.log(values)


</script>